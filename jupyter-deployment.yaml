apiVersion: apps/v1
kind: Deployment
metadata:
  name: jupyter-notebook-deployment
  labels: # задаем метки
    app: jupyter-notebook # Лейбл, указывающий на название приложения
    tier: frontend # Лейбл, указывающий на уровень приложения (фронтенд)
    environment: production # Среда развертывания (продакшн)
    version: v1.0 # Версия приложения
    owner: dev-team # Команда, ответственная за приложение
spec:
  replicas: 1 # количество реплик
  selector:
    matchLabels:
      app: jupyter-notebook
  template:
    metadata:
      labels:
        app: jupyter-notebook # Лейбл, который будет применен к создаваемым подам
        tier: frontend
        environment: production # Среда развертывания для подов
        version: v1.0 # Версия приложения для подов
        owner: dev-team # Команда, ответственная за приложение
    spec:
      containers:
      - name: jupyter-notebook # имя контейнера
        image: my-jupyter-notebook # имя собранного образа Docker для Jupyter Notebook
        imagePullPolicy: Never # явно указываем, что образ не будет загружаться из реестра, а используется локально
        ports:
        - containerPort: 8888 # порт, на котором контейнер будет слушать входящие запросы (стандартный порт для Jupyter Notebook)
        env: # переменные окружения
        - name: JUPYTER_ENABLE_LAB # Добавляем переменную окружения из ConfigMap
          valueFrom:
            configMapKeyRef: # ссылка на конфиг-мап
              name: jupyter-postgres-config # Используем созданный ConfigMap
              key: JUPYTER_ENABLE_LAB # ключ в конфиг-мапе
      initContainers: # контейнер-инициализатор
        - name: init-container # имя init-контейнера
          image: alpine:latest # образ для инициализации
          command: ["sh", "-c", "echo 'Initialization complete'"] # команда для инициализации